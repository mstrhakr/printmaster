name: CD Agent
run-name: "CD Agent: ${{ github.ref_name }}"

on:
  push:
    tags:
      - 'agent-v[0-9]+.[0-9]+.[0-9]+'
  workflow_dispatch: {}

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read

jobs:
  # Wait for CI to pass on this commit
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: read
    steps:
    - name: Wait for CI checks to pass
      uses: fountainhead/action-wait-for-check@5a908a24814494009c4bb27c242ea38c93c593be # v1.2.0
      id: wait-for-ci
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        checkName: CI Passed
        ref: ${{ github.sha }}
        timeoutSeconds: 900
        intervalSeconds: 15

    - name: Fail if CI did not pass
      if: steps.wait-for-ci.outputs.conclusion != 'success'
      run: |
        echo "CI check 'CI Passed' did not pass (conclusion: ${{ steps.wait-for-ci.outputs.conclusion }})"
        exit 1

  build-agent:
    name: Build Agent Binaries
    needs: [wait-for-ci]
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
          - os: ubuntu-latest
            goos: linux
            goarch: arm64
          - os: windows-latest
            goos: windows
            goarch: amd64
          - os: macos-latest
            goos: darwin
            goarch: amd64
          - os: macos-latest
            goos: darwin
            goarch: arm64
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
      with:
        fetch-depth: 0
    
    - name: Set up Go
      uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5
      with:
        go-version: '1.24'
        cache-dependency-path: |
          common/go.sum
          agent/go.sum
    
    - name: Get version
      id: version
      shell: bash
      run: |
        echo "agent_version=$(cat agent/VERSION)" >> $GITHUB_OUTPUT
        echo "git_commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "build_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
    
    - name: Build Agent
      working-directory: ./agent
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        go build -ldflags="-s -w -X 'main.Version=${{ steps.version.outputs.agent_version }}' -X 'main.BuildTime=${{ steps.version.outputs.build_time }}' -X 'main.GitCommit=${{ steps.version.outputs.git_commit }}' -X 'main.BuildType=release'" -o printmaster-agent-v${{ steps.version.outputs.agent_version }}-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.goos == 'windows' && '.exe' || '' }} .

    - name: Build Debian Package (Linux)
      if: matrix.goos == 'linux'
      working-directory: ./agent
      run: |
        # Copy binary to expected location for build script
        cp "printmaster-agent-v${{ steps.version.outputs.agent_version }}-linux-${{ matrix.goarch }}" "printmaster-agent"
        chmod +x build-deb.sh
        ./build-deb.sh "${{ steps.version.outputs.agent_version }}" "${{ matrix.goarch }}"

    - name: Upload Debian Package
      if: matrix.goos == 'linux'
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.3.0
      with:
        name: agent-deb-${{ matrix.goarch }}
        path: agent/dist/*.deb

    - name: Install WiX Toolset (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $wixUrl = 'https://github.com/wixtoolset/wix3/releases/download/wix3112rtm/wix311-binaries.zip'
        $wixRoot = Join-Path $env:RUNNER_TEMP 'wix311'
        if (!(Test-Path $wixRoot)) {
          New-Item -ItemType Directory -Path $wixRoot | Out-Null
        }
        $zipPath = Join-Path $wixRoot 'wix.zip'
        Invoke-WebRequest -Uri $wixUrl -OutFile $zipPath -UseBasicParsing
        Expand-Archive -Path $zipPath -DestinationPath $wixRoot -Force
        Remove-Item $zipPath -Force
        $binPath = Join-Path $wixRoot 'wix311-binaries'
        if (!(Test-Path (Join-Path $binPath 'candle.exe'))) {
          $binPath = $wixRoot
        }
        "$binPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Build Agent MSI
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $agentVersion = '${{ steps.version.outputs.agent_version }}'
        if (-not $agentVersion) { throw 'agent version not detected' }
        $agentExe = Join-Path (Get-Location) "agent\printmaster-agent-v${agentVersion}-windows-amd64.exe"
        if (!(Test-Path $agentExe)) {
          throw "Agent binary not found at $agentExe"
        }
        $distDir = Join-Path (Get-Location) 'agent\dist'
        if (!(Test-Path $distDir)) {
          New-Item -ItemType Directory -Path $distDir | Out-Null
        }
        $wixobj = Join-Path $distDir 'printmaster-agent.wixobj'
        $wxs = 'build\windows\msi\printmaster-agent.wxs'
        $candleArgs = @(
          '-nologo',
          "-dProductVersion=$agentVersion",
          "-dAgentBinaryPath=$agentExe",
          '-out', $wixobj,
          $wxs
        )
        & candle.exe @candleArgs
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
        $msiName = "printmaster-agent-v${agentVersion}-windows-amd64.msi"
        $msiPath = Join-Path $distDir $msiName
        $lightArgs = @(
          '-nologo',
          '-out', $msiPath,
          $wixobj
        )
        & light.exe @lightArgs
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
    
    - name: Upload Agent Binary
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.3.0
      with:
        name: agent-binary-${{ matrix.goos }}-${{ matrix.goarch }}
        path: agent/printmaster-agent-v${{ steps.version.outputs.agent_version }}-${{ matrix.goos }}-${{ matrix.goarch }}*

    - name: Upload Agent MSI
      if: matrix.os == 'windows-latest'
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.3.0
      with:
        name: agent-windows-msi
        path: agent/dist/printmaster-agent-v${{ steps.version.outputs.agent_version }}-windows-amd64.msi

  build-docker:
    name: Build Docker (${{ matrix.platform }})
    needs: [wait-for-ci]
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            suffix: amd64
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            suffix: arm64
          - platform: linux/arm/v7
            runner: ubuntu-latest
            suffix: armv7
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
    
    - name: Set up QEMU
      if: matrix.platform == 'linux/arm/v7'
      uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3
      with:
        platforms: linux/arm/v7
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get version
      id: version
      run: |
        echo "version=$(cat agent/VERSION)" >> $GITHUB_OUTPUT
        echo "git_commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "build_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
    
    - name: Build and push by digest
      id: build
      uses: docker/build-push-action@14487ce63c7a62a4a324b0bfb37086795e31c6c1 # v5
      with:
        context: .
        file: ./agent/Dockerfile
        platforms: ${{ matrix.platform }}
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          BUILD_TIME=${{ steps.version.outputs.build_time }}
          GIT_COMMIT=${{ steps.version.outputs.git_commit }}
        cache-from: type=gha,scope=agent-${{ matrix.suffix }}
        cache-to: type=gha,mode=max,scope=agent-${{ matrix.suffix }}
        outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-agent,push-by-digest=true,name-canonical=true,push=true
        provenance: false
        sbom: false
    
    - name: Export digest
      run: |
        mkdir -p /tmp/digests
        digest="${{ steps.build.outputs.digest }}"
        touch "/tmp/digests/${digest#sha256:}"
    
    - name: Upload digest
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.3.0
      with:
        name: agent-digests-${{ matrix.suffix }}
        path: /tmp/digests/*
        if-no-files-found: error
        retention-days: 1

  merge-docker:
    name: Create Docker Manifest
    needs: [build-docker]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
    
    - name: Download digests
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
      with:
        path: /tmp/digests
        pattern: agent-digests-*
        merge-multiple: true
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get version
      id: version
      run: |
        echo "version=$(cat agent/VERSION)" >> $GITHUB_OUTPUT
        echo "git_commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-agent
        tags: |
          type=semver,pattern={{version}},value=${{ steps.version.outputs.version }}
          type=semver,pattern={{major}}.{{minor}},value=${{ steps.version.outputs.version }}
          type=raw,value=latest,enable=true
          type=raw,value=${{ steps.version.outputs.version }}
        labels: |
          org.opencontainers.image.description=PrintMaster Agent container image (build ${{ steps.version.outputs.version }} / commit ${{ steps.version.outputs.git_commit }})
    
    - name: Create manifest list and push
      working-directory: /tmp/digests
      run: |
        docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
          $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-agent@sha256:%s ' *)
    
    - name: Inspect image
      run: |
        docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-agent:${{ steps.version.outputs.version }}

  build-rpm:
    name: Build RPM Packages (Fedora)
    needs: [build-agent]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    container:
      image: fedora:latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    
    steps:
    - name: Install dependencies
      run: |
        dnf install -y rpm-build systemd-rpm-macros git

    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0

    - name: Download Linux binary
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
      with:
        name: agent-binary-linux-${{ matrix.arch }}
        path: agent/

    - name: Get version
      id: version
      run: |
        echo "version=$(cat agent/VERSION)" >> $GITHUB_OUTPUT

    - name: Build RPM Package
      working-directory: ./agent
      run: |
        # Find and prepare the binary
        BINARY=$(ls printmaster-agent-v*-linux-${{ matrix.arch }} 2>/dev/null | head -n 1)
        if [ -z "$BINARY" ]; then
          echo "Error: No binary found matching printmaster-agent-v*-linux-${{ matrix.arch }}"
          ls -la
          exit 1
        fi
        cp "$BINARY" printmaster-agent
        chmod +x printmaster-agent build-rpm.sh
        ./build-rpm.sh "${{ steps.version.outputs.version }}" "${{ matrix.arch }}"

    - name: Upload RPM Package
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.3.0
      with:
        name: agent-rpm-${{ matrix.arch }}
        path: agent/dist/*.rpm

  release-agent:
    name: Create Agent Release
    needs: [build-agent, merge-docker, build-rpm]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
      with:
        fetch-depth: 0
    
    - name: Download release artifacts
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
      with:
        path: artifacts
        pattern: agent-*
        merge-multiple: false
    
    - name: Get version info
      id: version
      run: |
        AGENT_VERSION=$(cat agent/VERSION)
        echo "version=$AGENT_VERSION" >> $GITHUB_OUTPUT
        echo "tag=agent-v$AGENT_VERSION" >> $GITHUB_OUTPUT
        
        # Extract major.minor for compatible server matching
        MAJOR_MINOR=$(echo "$AGENT_VERSION" | sed 's/\.[^.]*$//')
        
        # Find latest server with matching minor version (e.g., agent 0.9.5 -> server 0.9.*)
        MATCHING_SERVER_TAG=$(git tag -l "server-v${MAJOR_MINOR}.*" --sort=-version:refname | head -n 1)
        
        if [ -n "$MATCHING_SERVER_TAG" ]; then
          echo "server_version=${MATCHING_SERVER_TAG#server-v}" >> $GITHUB_OUTPUT
          echo "server_tag=$MATCHING_SERVER_TAG" >> $GITHUB_OUTPUT
          echo "Found compatible server: $MATCHING_SERVER_TAG"
        else
          echo "server_version=" >> $GITHUB_OUTPUT
          echo "server_tag=" >> $GITHUB_OUTPUT
          echo "No compatible server found for v${MAJOR_MINOR}.*"
        fi
    
    - name: Prepare release binaries
      run: |
        cd artifacts
        for dir in */; do
          name="${dir%/}"
          binary=$(find "$dir" -maxdepth 1 -type f -name "printmaster-*" | head -n 1)
          if [ -n "$binary" ]; then
            cp "$binary" "./$(basename "$binary")"
            echo "Prepared: $(basename "$binary")"
          fi
        done
        echo "=== Release Binaries ==="
        ls -lh printmaster-* 2>/dev/null || true
    
    - name: Generate changelog
      id: changelog
      run: |
        TAG_NAME="agent-v${{ steps.version.outputs.version }}"
        VERSION="${{ steps.version.outputs.version }}"
        
        # Parse version components
        MAJOR=$(echo "$VERSION" | cut -d. -f1)
        MINOR=$(echo "$VERSION" | cut -d. -f2)
        PATCH=$(echo "$VERSION" | cut -d. -f3)
        
        # Determine release type and find appropriate comparison tag
        if [ "$PATCH" = "0" ] && [ "$MINOR" = "0" ]; then
          # Major release (x.0.0) - compare against last major
          RELEASE_TYPE="major"
          PREV_MAJOR=$((MAJOR - 1))
          LAST_TAG=$(git tag -l "agent-v${PREV_MAJOR}.*" --sort=-version:refname | head -n 1)
        elif [ "$PATCH" = "0" ]; then
          # Minor release (x.y.0) - compare against last minor's first tag
          RELEASE_TYPE="minor"
          PREV_MINOR=$((MINOR - 1))
          LAST_TAG=$(git tag -l "agent-v${MAJOR}.${PREV_MINOR}.*" --sort=-version:refname | head -n 1)
        else
          # Patch release - compare against previous patch
          RELEASE_TYPE="patch"
          LAST_TAG=$(git tag -l "agent-v*" --sort=-version:refname | grep -v "^${TAG_NAME}$" | head -n 1)
        fi
        
        echo "Release type: $RELEASE_TYPE, comparing against: ${LAST_TAG:-none}"
        
        if [ -z "$LAST_TAG" ]; then
          CHANGELOG="Initial release"
        else
          # Get commits, filter release commits, and categorize
          RAW_LOG=$(git log ${LAST_TAG}..${TAG_NAME} --pretty=format:"%s|||%h" --no-merges 2>/dev/null || echo "")
          
          if [ -z "$RAW_LOG" ]; then
            CHANGELOG="- Bug fixes and improvements"
          else
            # Categorize commits by conventional commit type
            FEATURES=""
            FIXES=""
            DOCS=""
            REFACTORS=""
            OTHER=""
            
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              MSG=$(echo "$line" | cut -d'|' -f1)
              HASH=$(echo "$line" | rev | cut -d'|' -f1 | rev)
              
              # Skip release commits
              echo "$MSG" | grep -q "^chore: Release" && continue
              echo "$MSG" | grep -q "^chore(release)" && continue
              
              # Categorize by type
              if echo "$MSG" | grep -qE "^feat(\([^)]+\))?:"; then
                DESC=$(echo "$MSG" | sed 's/^feat[^:]*: //')
                FEATURES="${FEATURES}- ${DESC} (${HASH})\n"
              elif echo "$MSG" | grep -qE "^fix(\([^)]+\))?:"; then
                DESC=$(echo "$MSG" | sed 's/^fix[^:]*: //')
                FIXES="${FIXES}- ${DESC} (${HASH})\n"
              elif echo "$MSG" | grep -qE "^docs(\([^)]+\))?:"; then
                DESC=$(echo "$MSG" | sed 's/^docs[^:]*: //')
                DOCS="${DOCS}- ${DESC} (${HASH})\n"
              elif echo "$MSG" | grep -qE "^refactor(\([^)]+\))?:"; then
                DESC=$(echo "$MSG" | sed 's/^refactor[^:]*: //')
                REFACTORS="${REFACTORS}- ${DESC} (${HASH})\n"
              elif ! echo "$MSG" | grep -qE "^(chore|test|ci|build)(\([^)]+\))?:"; then
                # Include non-chore/test/ci/build commits in OTHER
                OTHER="${OTHER}- ${MSG} (${HASH})\n"
              fi
            done <<< "$RAW_LOG"
            
            # Build changelog with sections
            CHANGELOG=""
            [ -n "$FEATURES" ] && CHANGELOG="${CHANGELOG}### ‚ú® Features\n${FEATURES}\n"
            [ -n "$FIXES" ] && CHANGELOG="${CHANGELOG}### üêõ Bug Fixes\n${FIXES}\n"
            [ -n "$REFACTORS" ] && CHANGELOG="${CHANGELOG}### ‚ôªÔ∏è Refactoring\n${REFACTORS}\n"
            [ -n "$DOCS" ] && CHANGELOG="${CHANGELOG}### üìö Documentation\n${DOCS}\n"
            [ -n "$OTHER" ] && CHANGELOG="${CHANGELOG}### üìù Other Changes\n${OTHER}\n"
            
            # Fallback if nothing was categorized
            if [ -z "$CHANGELOG" ]; then
              CHANGELOG="- Bug fixes and improvements"
            fi
          fi
        fi
        
        # For major releases, add a note about checking full changelog
        if [ "$RELEASE_TYPE" = "major" ]; then
          CHANGELOG="**üéâ Major Release**\n\nThis is a major version update. Please review the [full changelog](https://github.com/mstrhakr/printmaster/compare/${LAST_TAG}...${TAG_NAME}) for breaking changes.\n\n${CHANGELOG}"
        fi
        
        {
          echo 'CHANGELOG<<EOF'
          echo -e "$CHANGELOG"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@c95fe1489396fe8a9eb87c0abf8aa5b2ef267fda # v1
      with:
        tag_name: ${{ steps.version.outputs.tag }}
        name: PrintMaster Agent v${{ steps.version.outputs.version }}
        body: |
          ## PrintMaster Agent v${{ steps.version.outputs.version }}
          
          ### üìù Changes
          
          ${{ steps.changelog.outputs.CHANGELOG }}
          
          ---
          
          ### üì¶ Quick Install
          
          **Debian/Ubuntu (APT repo):**
          ```bash
          echo "deb [trusted=yes] https://mstrhakr.github.io/printmaster stable main" | sudo tee /etc/apt/sources.list.d/printmaster.list && sudo apt-get update && sudo apt-get install -y printmaster-agent
          ```
          
          **Fedora/RHEL (DNF repo):**
          ```bash
          sudo dnf config-manager addrepo --from-repofile=https://mstrhakr.github.io/printmaster/printmaster.repo && sudo dnf install -y printmaster-agent
          ```
          
          **Windows:** Download the MSI installer from Assets below.
          
          **Docker:**
          ```bash
          docker run -d -p 8080:8080 -v agent-data:/var/lib/printmaster/agent ghcr.io/mstrhakr/printmaster-agent:${{ steps.version.outputs.version }}
          ```
          
          Web UI at http://localhost:8080 after install.
          
          **Supported Platforms:** Debian/Ubuntu ‚Ä¢ Fedora/RHEL ‚Ä¢ Windows ‚Ä¢ Docker ‚Ä¢ macOS
          
          ---
          
          ### üñ•Ô∏è Server Download
          
          For multi-site management, you'll also need the PrintMaster Server:
          
          **Latest Server: v${{ steps.version.outputs.server_version }}** ‚Äî [View Release](https://github.com/mstrhakr/printmaster/releases/tag/${{ steps.version.outputs.server_tag }})
          
          ```bash
          # Docker (recommended)
          docker pull ghcr.io/mstrhakr/printmaster-server:latest
          ```
          
          ---
          
          ### ‚è±Ô∏è Build Information
          - **Workflow run:** ${{ github.run_id }}
          - **Commit:** ${{ github.sha }}
          
          ### üîó Links
          - [Documentation](https://github.com/mstrhakr/printmaster/tree/main/docs)
          - [Docker Images](https://github.com/mstrhakr/printmaster/pkgs/container/printmaster-agent)
          - [Issue Tracker](https://github.com/mstrhakr/printmaster/issues)
        files: artifacts/printmaster-*
        fail_on_unmatched_files: false
        draft: false
        prerelease: false

  update-package-repos:
    name: Update Package Repositories (APT + DNF)
    needs: [build-agent, build-rpm]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout gh-pages
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
      with:
        ref: gh-pages
        path: apt-repo
      continue-on-error: true

    - name: Initialize gh-pages if needed
      run: |
        if [ ! -d "apt-repo/.git" ]; then
          echo "Creating gh-pages branch..."
          mkdir -p apt-repo
          cd apt-repo
          git init
          git remote add origin https://github.com/${{ github.repository }}.git
          git checkout -b gh-pages
          echo "# PrintMaster Package Repository" > README.md
        fi

    - name: Download deb artifacts
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
      with:
        pattern: agent-deb-*
        path: downloads-deb
        merge-multiple: true

    - name: Download rpm artifacts
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
      with:
        pattern: agent-rpm-*
        path: downloads-rpm
        merge-multiple: true

    - name: Get version
      id: version
      run: |
        echo "version=$(cat apt-repo/../agent/VERSION 2>/dev/null || echo 'unknown')" >> $GITHUB_OUTPUT
      continue-on-error: true

    - name: Checkout main for version
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.3.0
      with:
        path: main-repo
        sparse-checkout: agent/VERSION

    - name: Get version from main
      id: main_version
      run: |
        echo "version=$(cat main-repo/agent/VERSION)" >> $GITHUB_OUTPUT

    - name: Install APT repo tools
      run: |
        sudo apt-get update
        sudo apt-get install -y dpkg-dev apt-utils gnupg createrepo-c rpm expect

    - name: Import GPG key
      env:
        GPG_PRIVATE_KEY: ${{ secrets.APT_GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
      run: |
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          echo "GPG key imported"
          
          # Export public key for users to download
          gpg --armor --export > apt-repo/gpg.key
          echo "Public key exported to gpg.key"
        else
          echo "No GPG key configured, skipping import"
        fi

    - name: Setup APT repository structure
      run: |
        cd apt-repo
        
        # Create directory structure
        mkdir -p pool/main
        mkdir -p dists/stable/main/binary-amd64
        mkdir -p dists/stable/main/binary-arm64
        
        # Copy new .deb files to pool
        if ls ../downloads-deb/*.deb 1>/dev/null 2>&1; then
          cp ../downloads-deb/*.deb pool/main/
          echo "Copied packages to pool:"
          ls -la pool/main/
        else
          echo "No .deb packages found in downloads-deb"
          ls -la ../downloads-deb/ || true
        fi

    - name: Setup DNF repository structure
      run: |
        cd apt-repo
        
        # Create RPM directory structure
        mkdir -p rpm/packages
        
        # Copy new .rpm files to rpm directory
        if ls ../downloads-rpm/*.rpm 1>/dev/null 2>&1; then
          cp ../downloads-rpm/*.rpm rpm/packages/
          echo "Copied RPM packages:"
          ls -la rpm/packages/
        else
          echo "No .rpm packages found in downloads-rpm"
          ls -la ../downloads-rpm/ || true
        fi

    - name: Generate APT repository metadata
      run: |
        cd apt-repo
        
        # Check if we have any packages
        if ! ls pool/main/*.deb 1>/dev/null 2>&1; then
          echo "No packages in pool, skipping metadata generation"
          exit 0
        fi
        
        # Generate Packages files for each architecture
        for arch in amd64 arm64; do
          echo "Generating Packages for $arch..."
          mkdir -p dists/stable/main/binary-$arch
          
          # Generate Packages file - run from repo root so paths are correct (pool/main/...)
          dpkg-scanpackages --arch $arch pool/main /dev/null > dists/stable/main/binary-$arch/Packages 2>/dev/null || true
          
          # Compress
          gzip -9c dists/stable/main/binary-$arch/Packages > dists/stable/main/binary-$arch/Packages.gz
          
          echo "Packages for $arch:"
          cat dists/stable/main/binary-$arch/Packages || true
        done

    - name: Generate Release file
      run: |
        cd apt-repo
        
        # Check if we have packages
        if ! ls pool/main/*.deb 1>/dev/null 2>&1; then
          echo "No packages, skipping Release generation"
          exit 0
        fi
        
        cd dists/stable
        
        # Generate Release file
        cat > Release << EOF
        Origin: PrintMaster
        Label: PrintMaster
        Suite: stable
        Codename: stable
        Architectures: amd64 arm64
        Components: main
        Description: PrintMaster Agent APT Repository
        Date: $(date -Ru)
        EOF
        
        # Add checksums
        {
          echo "MD5Sum:"
          find main -type f \( -name "Packages" -o -name "Packages.gz" \) -exec sh -c 'echo " $(md5sum "$1" | cut -d" " -f1) $(stat -c%s "$1") $1"' _ {} \;
          echo "SHA256:"
          find main -type f \( -name "Packages" -o -name "Packages.gz" \) -exec sh -c 'echo " $(sha256sum "$1" | cut -d" " -f1) $(stat -c%s "$1") $1"' _ {} \;
        } >> Release
        
        echo "Release file:"
        cat Release

    - name: Sign Release file
      env:
        GPG_PRIVATE_KEY: ${{ secrets.APT_GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
      run: |
        # Normalize passphrase (treat whitespace-only as empty)
        GPG_PASSPHRASE="$(echo "$GPG_PASSPHRASE" | xargs)"
        
        if [ -z "$GPG_PRIVATE_KEY" ]; then
          echo "No GPG key configured, skipping signing"
          exit 0
        fi
        
        cd apt-repo/dists/stable
        
        # Sign Release file
        gpg --batch --yes --pinentry-mode loopback \
          --passphrase "$GPG_PASSPHRASE" \
          --armor --detach-sign --output Release.gpg Release
        
        gpg --batch --yes --pinentry-mode loopback \
          --passphrase "$GPG_PASSPHRASE" \
          --armor --clearsign --output InRelease Release
        
        echo "Release signed"

    - name: Sign RPM packages
      env:
        GPG_PRIVATE_KEY: ${{ secrets.APT_GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
      run: |
        # Normalize passphrase (treat whitespace-only as empty)
        GPG_PASSPHRASE="$(echo "$GPG_PASSPHRASE" | xargs)"
        
        if [ -z "$GPG_PRIVATE_KEY" ]; then
          echo "No GPG key configured, skipping RPM signing"
          exit 0
        fi
        
        cd apt-repo
        
        # Check if we have RPM packages
        if ! ls rpm/packages/*.rpm 1>/dev/null 2>&1; then
          echo "No RPM packages to sign"
          exit 0
        fi
        
        # Get the GPG key ID
        GPG_KEY_ID=$(gpg --list-keys --keyid-format SHORT | grep -A1 "^pub" | tail -1 | awk '{print $1}')
        echo "Using GPG key: $GPG_KEY_ID"
        
        # Configure rpmmacros for signing
        mkdir -p ~/.gnupg
        echo "%_gpg_name $GPG_KEY_ID" >> ~/.rpmmacros
        echo "%__gpg_sign_cmd %{__gpg} gpg --batch --verbose --no-armor --pinentry-mode loopback --passphrase \"$GPG_PASSPHRASE\" -u \"%{_gpg_name}\" -sbo %{__signature_filename} --digest-algo sha256 %{__plaintext_filename}" >> ~/.rpmmacros
        
        # Sign each RPM package
        for rpm in rpm/packages/*.rpm; do
          echo "Signing $rpm..."
          rpm --addsign "$rpm" <<< "$GPG_PASSPHRASE" || {
            # Alternative method using rpmsign directly
            echo "Trying alternative signing method..."
            rpmsign --addsign --key-id="$GPG_KEY_ID" "$rpm" <<< "$GPG_PASSPHRASE" || {
              echo "Warning: Failed to sign $rpm, trying expect-based approach..."
              # Final fallback - use expect if available
              if command -v expect &> /dev/null; then
                expect -c "
                  spawn rpm --addsign $rpm
                  expect \"Enter pass phrase:\"
                  send \"$GPG_PASSPHRASE\r\"
                  expect eof
                "
              else
                echo "ERROR: Could not sign $rpm"
              fi
            }
          }
        done
        
        echo "Verifying RPM signatures:"
        for rpm in rpm/packages/*.rpm; do
          rpm -K "$rpm" || true
        done

    - name: Generate DNF repository metadata
      run: |
        cd apt-repo
        
        # Check if we have any RPM packages
        if ! ls rpm/packages/*.rpm 1>/dev/null 2>&1; then
          echo "No RPM packages in rpm/packages, skipping metadata generation"
          exit 0
        fi
        
        echo "Generating DNF/YUM repository metadata..."
        createrepo_c rpm/
        
        echo "Repository metadata generated:"
        ls -la rpm/repodata/

    - name: Sign RPM repository metadata
      env:
        GPG_PRIVATE_KEY: ${{ secrets.APT_GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
      run: |
        # Normalize passphrase (treat whitespace-only as empty)
        GPG_PASSPHRASE="$(echo "$GPG_PASSPHRASE" | xargs)"
        
        if [ -z "$GPG_PRIVATE_KEY" ]; then
          echo "No GPG key configured, skipping RPM signing"
          exit 0
        fi
        
        cd apt-repo
        
        # Check if we have RPM packages
        if ! ls rpm/packages/*.rpm 1>/dev/null 2>&1; then
          echo "No RPM packages to sign"
          exit 0
        fi
        
        # Sign repomd.xml
        if [ -f rpm/repodata/repomd.xml ]; then
          gpg --batch --yes --pinentry-mode loopback \
            --passphrase "$GPG_PASSPHRASE" \
            --armor --detach-sign --output rpm/repodata/repomd.xml.asc rpm/repodata/repomd.xml
          echo "RPM repository metadata signed"
        fi

    - name: Create repo files
      run: |
        cd apt-repo
        
        # Create downloadable .repo file for Fedora/RHEL
        cat > printmaster.repo << 'EOF'
        [printmaster]
        name=PrintMaster Repository
        baseurl=https://mstrhakr.github.io/printmaster/rpm
        enabled=1
        gpgcheck=1
        gpgkey=https://mstrhakr.github.io/printmaster/gpg.key
        EOF

    - name: Create index page
      run: |
        cd apt-repo
        
        cat > index.html << 'EOF'
        <!DOCTYPE html>
        <html>
        <head>
          <title>PrintMaster Package Repository</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 900px; margin: 50px auto; padding: 20px; }
            h1 { color: #333; }
            h2 { color: #555; border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-top: 30px; }
            h3 { color: #666; }
            pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
            code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
            .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
            .tab { padding: 10px 20px; background: #e0e0e0; border-radius: 5px; cursor: pointer; }
            .tab.active { background: #333; color: white; }
          </style>
        </head>
        <body>
          <h1>üñ®Ô∏è PrintMaster Package Repository</h1>
          
          <p>Official package repositories for <a href="https://github.com/mstrhakr/printmaster">PrintMaster Agent</a>.</p>
          
          <h2>Debian/Ubuntu (APT)</h2>
          
          <h3>Quick Install</h3>
          <pre><code># Add repository
        echo "deb [trusted=yes] https://mstrhakr.github.io/printmaster stable main" | sudo tee /etc/apt/sources.list.d/printmaster.list

        # Update and install
        sudo apt-get update
        sudo apt-get install printmaster-agent</code></pre>

          <h3>With GPG Verification (Recommended)</h3>
          <pre><code># Download and add GPG key
        curl -fsSL https://mstrhakr.github.io/printmaster/gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/printmaster.gpg

        # Add repository with signed-by
        echo "deb [signed-by=/usr/share/keyrings/printmaster.gpg] https://mstrhakr.github.io/printmaster stable main" | sudo tee /etc/apt/sources.list.d/printmaster.list

        # Update and install
        sudo apt-get update
        sudo apt-get install printmaster-agent</code></pre>

          <h2>Fedora/RHEL (DNF)</h2>
          
          <h3>Quick Install (One-liner)</h3>
          <pre><code># Add repository and install
        sudo dnf config-manager addrepo --from-repofile=https://mstrhakr.github.io/printmaster/printmaster.repo
        sudo dnf install printmaster-agent</code></pre>

          <h3>With GPG Verification (Recommended)</h3>
          <pre><code># Import GPG key first
        sudo rpm --import https://mstrhakr.github.io/printmaster/gpg.key

        # Add repository and install
        sudo dnf config-manager addrepo --from-repofile=https://mstrhakr.github.io/printmaster/printmaster.repo
        sudo dnf install printmaster-agent</code></pre>

          <h2>After Installation</h2>
          <pre><code># Start the service
        sudo systemctl start printmaster-agent
        sudo systemctl enable printmaster-agent</code></pre>
          
          <p>Web UI: <code>http://localhost:8000</code></p>
          
          <h2>Links</h2>
          <ul>
            <li><a href="https://github.com/mstrhakr/printmaster">GitHub Repository</a></li>
            <li><a href="https://github.com/mstrhakr/printmaster/releases">Releases</a></li>
          </ul>
        </body>
        </html>
        EOF

    - name: Commit and push changes
      run: |
        cd apt-repo
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        git add -A
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update package repositories (APT + DNF) - v${{ steps.main_version.outputs.version }}"
          git push origin gh-pages
        fi
        # GitHub Pages automatically serves the gh-pages branch - no artifact upload needed
